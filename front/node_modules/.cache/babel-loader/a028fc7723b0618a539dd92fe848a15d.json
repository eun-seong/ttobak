{"ast":null,"code":"var _eventNames;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces';\nimport { eventShouldStartDrag, eventShouldEndDrag, isTouchEvent } from './utils/predicates';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets';\nimport { distance, inAngleRanges } from './utils/math';\nimport { supportsPassive } from './utils/supportsPassive';\nimport { OptionsReader } from './OptionsReader';\nvar eventNames = (_eventNames = {}, _defineProperty(_eventNames, ListenerType.mouse, {\n  start: 'mousedown',\n  move: 'mousemove',\n  end: 'mouseup',\n  contextmenu: 'contextmenu'\n}), _defineProperty(_eventNames, ListenerType.touch, {\n  start: 'touchstart',\n  move: 'touchmove',\n  end: 'touchend'\n}), _defineProperty(_eventNames, ListenerType.keyboard, {\n  keydown: 'keydown'\n}), _eventNames);\nexport var TouchBackendImpl = /*#__PURE__*/function () {\n  function TouchBackendImpl(manager, context, options) {\n    var _this = this;\n\n    _classCallCheck(this, TouchBackendImpl);\n\n    this.getSourceClientOffset = function (sourceId) {\n      var element = _this.sourceNodes.get(sourceId);\n\n      return element && getNodeClientOffset(element);\n    };\n\n    this.handleTopMoveStartCapture = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      _this.moveStartSourceIds = [];\n    };\n\n    this.handleMoveStart = function (sourceId) {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(_this.moveStartSourceIds)) {\n        _this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n\n    this.handleTopMoveStart = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      } // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\n      var clientOffset = getEventClientOffset(e);\n\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          _this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n\n        _this._mouseClientOffset = clientOffset;\n      }\n\n      _this.waitingForDelay = false;\n    };\n\n    this.handleTopMoveStartDelay = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;\n      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n      _this.waitingForDelay = true;\n    };\n\n    this.handleTopMoveCapture = function () {\n      _this.dragOverTargetIds = [];\n    };\n\n    this.handleMove = function (_evt, targetId) {\n      if (_this.dragOverTargetIds) {\n        _this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n\n    this.handleTopMove = function (e) {\n      if (_this.timeout) {\n        clearTimeout(_this.timeout);\n      }\n\n      if (!_this.document || _this.waitingForDelay) {\n        return;\n      }\n\n      var moveStartSourceIds = _this.moveStartSourceIds,\n          dragOverTargetIds = _this.dragOverTargetIds;\n      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n      var clientOffset = getEventClientOffset(e, _this.lastTargetTouchFallback);\n\n      if (!clientOffset) {\n        return;\n      } // If the touch move started as a scroll, or is is between the scroll angles\n\n\n      if (_this._isScrolling || !_this.monitor.isDragging() && inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {\n        _this._isScrolling = true;\n        return;\n      } // If we're not dragging and we've moved a little, that counts as a drag start\n\n\n      if (!_this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n      _this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n        _this.moveStartSourceIds = undefined;\n\n        _this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: _this._mouseClientOffset,\n          getSourceClientOffset: _this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n\n      if (!_this.monitor.isDragging()) {\n        return;\n      }\n\n      var sourceNode = _this.sourceNodes.get(_this.monitor.getSourceId());\n\n      _this.installSourceNodeRemovalObserver(sourceNode);\n\n      _this.actions.publishDragSource();\n\n      if (e.cancelable) e.preventDefault(); // Get the node elements of the hovered DropTargets\n\n      var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) {\n        return _this.targetNodes.get(key);\n      }).filter(function (e) {\n        return !!e;\n      }); // Get the a ordered list of nodes that are touched by\n\n      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y); // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\n      var elementsAtPointExtended = [];\n\n      for (var nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n\n        var currentNode = elementsAtPoint[nodeId];\n        elementsAtPointExtended.push(currentNode);\n\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n\n      var orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(function (node) {\n        return dragOverTargetNodes.indexOf(node) > -1;\n      }) // Map back the nodes elements to targetIds\n      .map(function (node) {\n        return _this._getDropTargetId(node);\n      }) // Filter off possible null rows\n      .filter(function (node) {\n        return !!node;\n      }).filter(function (id, index, ids) {\n        return ids.indexOf(id) === index;\n      }); // Invoke hover for drop targets when source node is still over and pointer is outside\n\n      if (enableHoverOutsideTarget) {\n        for (var targetId in _this.targetNodes) {\n          var targetNode = _this.targetNodes.get(targetId);\n\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      } // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\n\n      orderedDragOverTargetIds.reverse();\n\n      _this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n     *\n     * visible for testing\n     */\n\n\n    this._getDropTargetId = function (node) {\n      var keys = _this.targetNodes.keys();\n\n      var next = keys.next();\n\n      while (next.done === false) {\n        var targetId = next.value;\n\n        if (node === _this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n\n      return undefined;\n    };\n\n    this.handleTopMoveEndCapture = function (e) {\n      _this._isScrolling = false;\n      _this.lastTargetTouchFallback = undefined;\n\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n\n      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n        _this.moveStartSourceIds = undefined;\n        return;\n      }\n\n      if (e.cancelable) e.preventDefault();\n      _this._mouseClientOffset = {};\n\n      _this.uninstallSourceNodeRemovalObserver();\n\n      _this.actions.drop();\n\n      _this.actions.endDrag();\n    };\n\n    this.handleCancelOnEscape = function (e) {\n      if (e.key === 'Escape' && _this.monitor.isDragging()) {\n        _this._mouseClientOffset = {};\n\n        _this.uninstallSourceNodeRemovalObserver();\n\n        _this.actions.endDrag();\n      }\n    };\n\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n  /**\n   * Generate profiling statistics for the HTML5Backend.\n   */\n\n\n  _createClass(TouchBackendImpl, [{\n    key: \"profile\",\n    value: function profile() {\n      var _this$dragOverTargetI;\n\n      return {\n        sourceNodes: this.sourceNodes.size,\n        sourcePreviewNodes: this.sourcePreviewNodes.size,\n        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n        targetNodes: this.targetNodes.size,\n        dragOverTargetIds: ((_this$dragOverTargetI = this.dragOverTargetIds) === null || _this$dragOverTargetI === void 0 ? void 0 : _this$dragOverTargetI.length) || 0\n      };\n    } // public for test\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      if (!this.window) {\n        return;\n      }\n\n      invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n      TouchBackendImpl.isSetUp = true;\n      this.addEventListener(this.window, 'start', this.getTopMoveStartHandler());\n      this.addEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.addEventListener(this.window, 'move', this.handleTopMove);\n      this.addEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.addEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.addEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.addEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (!this.window) {\n        return;\n      }\n\n      TouchBackendImpl.isSetUp = false;\n      this._mouseClientOffset = {};\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStart);\n      this.removeEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.removeEventListener(this.window, 'move', this.handleTopMove);\n      this.removeEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.removeEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.removeEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n\n      this.uninstallSourceNodeRemovalObserver();\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.addEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.removeEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"connectDragSource\",\n    value: function connectDragSource(sourceId, node) {\n      var _this2 = this;\n\n      var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n      this.sourceNodes.set(sourceId, node);\n      this.addEventListener(node, 'start', handleMoveStart);\n      return function () {\n        _this2.sourceNodes.delete(sourceId);\n\n        _this2.removeEventListener(node, 'start', handleMoveStart);\n      };\n    }\n  }, {\n    key: \"connectDragPreview\",\n    value: function connectDragPreview(sourceId, node, options) {\n      var _this3 = this;\n\n      this.sourcePreviewNodeOptions.set(sourceId, options);\n      this.sourcePreviewNodes.set(sourceId, node);\n      return function () {\n        _this3.sourcePreviewNodes.delete(sourceId);\n\n        _this3.sourcePreviewNodeOptions.delete(sourceId);\n      };\n    }\n  }, {\n    key: \"connectDropTarget\",\n    value: function connectDropTarget(targetId, node) {\n      var _this4 = this;\n\n      if (!this.document) {\n        return function () {\n          /* noop */\n        };\n      }\n\n      var handleMove = function handleMove(e) {\n        if (!_this4.document || !_this4.monitor.isDragging()) {\n          return;\n        }\n\n        var coords;\n        /**\n         * Grab the coordinates for the current mouse/touch position\n         */\n\n        switch (e.type) {\n          case eventNames.mouse.move:\n            coords = {\n              x: e.clientX,\n              y: e.clientY\n            };\n            break;\n\n          case eventNames.touch.move:\n            coords = {\n              x: e.touches[0].clientX,\n              y: e.touches[0].clientY\n            };\n            break;\n        }\n        /**\n         * Use the coordinates to grab the element the drag ended on.\n         * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n         */\n\n\n        var droppedOn = coords != null ? _this4.document.elementFromPoint(coords.x, coords.y) : undefined;\n        var childMatch = droppedOn && node.contains(droppedOn);\n\n        if (droppedOn === node || childMatch) {\n          return _this4.handleMove(e, targetId);\n        }\n      };\n      /**\n       * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n       */\n\n\n      this.addEventListener(this.document.body, 'move', handleMove);\n      this.targetNodes.set(targetId, node);\n      return function () {\n        if (_this4.document) {\n          _this4.targetNodes.delete(targetId);\n\n          _this4.removeEventListener(_this4.document.body, 'move', handleMove);\n        }\n      };\n    }\n  }, {\n    key: \"getTopMoveStartHandler\",\n    value: function getTopMoveStartHandler() {\n      if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n        return this.handleTopMoveStart;\n      }\n\n      return this.handleTopMoveStartDelay;\n    }\n  }, {\n    key: \"installSourceNodeRemovalObserver\",\n    value: function installSourceNodeRemovalObserver(node) {\n      var _this5 = this;\n\n      this.uninstallSourceNodeRemovalObserver();\n      this.draggedSourceNode = node;\n      this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n        if (node && !node.parentElement) {\n          _this5.resurrectSourceNode();\n\n          _this5.uninstallSourceNodeRemovalObserver();\n        }\n      });\n\n      if (!node || !node.parentElement) {\n        return;\n      }\n\n      this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n        childList: true\n      });\n    }\n  }, {\n    key: \"resurrectSourceNode\",\n    value: function resurrectSourceNode() {\n      if (this.document && this.draggedSourceNode) {\n        this.draggedSourceNode.style.display = 'none';\n        this.draggedSourceNode.removeAttribute('data-reactid');\n        this.document.body.appendChild(this.draggedSourceNode);\n      }\n    }\n  }, {\n    key: \"uninstallSourceNodeRemovalObserver\",\n    value: function uninstallSourceNodeRemovalObserver() {\n      if (this.draggedSourceNodeRemovalObserver) {\n        this.draggedSourceNodeRemovalObserver.disconnect();\n      }\n\n      this.draggedSourceNodeRemovalObserver = undefined;\n      this.draggedSourceNode = undefined;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.options.window;\n    } // public for test\n\n  }, {\n    key: \"document\",\n    get: function get() {\n      if (this.window) {\n        return this.window.document;\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return TouchBackendImpl;\n}();","map":{"version":3,"sources":["/Users/eun/Projects/FirstPenguin/first-penguin/front/node_modules/react-dnd-touch-backend/dist/esm/TouchBackendImpl.js"],"names":["_eventNames","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","_defineProperty","obj","value","invariant","ListenerType","eventShouldStartDrag","eventShouldEndDrag","isTouchEvent","getEventClientOffset","getNodeClientOffset","distance","inAngleRanges","supportsPassive","OptionsReader","eventNames","mouse","start","move","end","contextmenu","touch","keyboard","keydown","TouchBackendImpl","manager","context","options","_this","getSourceClientOffset","sourceId","element","sourceNodes","get","handleTopMoveStartCapture","e","moveStartSourceIds","handleMoveStart","Array","isArray","unshift","handleTopMoveStart","clientOffset","lastTargetTouchFallback","targetTouches","_mouseClientOffset","waitingForDelay","handleTopMoveStartDelay","delay","type","delayTouchStart","delayMouseStart","timeout","setTimeout","bind","handleTopMoveCapture","dragOverTargetIds","handleMove","_evt","targetId","handleTopMove","clearTimeout","document","enableHoverOutsideTarget","_isScrolling","monitor","isDragging","x","y","scrollAngleRanges","hasOwnProperty","touchSlop","undefined","actions","beginDrag","publishSource","sourceNode","getSourceId","installSourceNodeRemovalObserver","publishDragSource","cancelable","preventDefault","dragOverTargetNodes","map","targetNodes","filter","elementsAtPoint","getDropTargetElementsAtPoint","elementsFromPoint","elementsAtPointExtended","nodeId","currentNode","push","parentElement","indexOf","orderedDragOverTargetIds","node","_getDropTargetId","id","index","ids","targetNode","contains","reverse","hover","keys","next","done","handleTopMoveEndCapture","didDrop","uninstallSourceNodeRemovalObserver","drop","endDrag","handleCancelOnEscape","getActions","getMonitor","Map","sourcePreviewNodes","sourcePreviewNodeOptions","listenerTypes","enableMouseEvents","enableTouchEvents","enableKeyboardEvents","profile","_this$dragOverTargetI","size","setup","window","isSetUp","addEventListener","getTopMoveStartHandler","ignoreContextMenu","teardown","removeEventListener","subject","event","handler","capture","passive","forEach","listenerType","evt","connectDragSource","_this2","set","delete","connectDragPreview","_this3","connectDropTarget","_this4","coords","clientX","clientY","touches","droppedOn","elementFromPoint","childMatch","body","_this5","draggedSourceNode","draggedSourceNodeRemovalObserver","MutationObserver","resurrectSourceNode","observe","childList","style","display","removeAttribute","appendChild","disconnect"],"mappings":"AAAA,IAAIA,WAAJ;;AAEA,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBd,WAAtB,EAAmCe,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBb,iBAAiB,CAACF,WAAW,CAACiB,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBd,iBAAiB,CAACF,WAAD,EAAcgB,WAAd,CAAjB;AAA6C,SAAOhB,WAAP;AAAqB;;AAEvN,SAASkB,eAAT,CAAyBC,GAAzB,EAA8BN,GAA9B,EAAmCO,KAAnC,EAA0C;AAAE,MAAIP,GAAG,IAAIM,GAAX,EAAgB;AAAER,IAAAA,MAAM,CAACC,cAAP,CAAsBO,GAAtB,EAA2BN,GAA3B,EAAgC;AAAEO,MAAAA,KAAK,EAAEA,KAAT;AAAgBZ,MAAAA,UAAU,EAAE,IAA5B;AAAkCC,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAES,IAAAA,GAAG,CAACN,GAAD,CAAH,GAAWO,KAAX;AAAmB;;AAAC,SAAOD,GAAP;AAAa;;AAEjN,SAASE,SAAT,QAA0B,sBAA1B;AACA,SAASC,YAAT,QAA6B,cAA7B;AACA,SAASC,oBAAT,EAA+BC,kBAA/B,EAAmDC,YAAnD,QAAuE,oBAAvE;AACA,SAASC,oBAAT,EAA+BC,mBAA/B,QAA0D,iBAA1D;AACA,SAASC,QAAT,EAAmBC,aAAnB,QAAwC,cAAxC;AACA,SAASC,eAAT,QAAgC,yBAAhC;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,IAAIC,UAAU,IAAInC,WAAW,GAAG,EAAd,EAAkBqB,eAAe,CAACrB,WAAD,EAAcyB,YAAY,CAACW,KAA3B,EAAkC;AACnFC,EAAAA,KAAK,EAAE,WAD4E;AAEnFC,EAAAA,IAAI,EAAE,WAF6E;AAGnFC,EAAAA,GAAG,EAAE,SAH8E;AAInFC,EAAAA,WAAW,EAAE;AAJsE,CAAlC,CAAjC,EAKdnB,eAAe,CAACrB,WAAD,EAAcyB,YAAY,CAACgB,KAA3B,EAAkC;AACnDJ,EAAAA,KAAK,EAAE,YAD4C;AAEnDC,EAAAA,IAAI,EAAE,WAF6C;AAGnDC,EAAAA,GAAG,EAAE;AAH8C,CAAlC,CALD,EASdlB,eAAe,CAACrB,WAAD,EAAcyB,YAAY,CAACiB,QAA3B,EAAqC;AACtDC,EAAAA,OAAO,EAAE;AAD6C,CAArC,CATD,EAWd3C,WAXU,CAAd;AAYA,OAAO,IAAI4C,gBAAgB,GAAG,aAAa,YAAY;AACrD,WAASA,gBAAT,CAA0BC,OAA1B,EAAmCC,OAAnC,EAA4CC,OAA5C,EAAqD;AACnD,QAAIC,KAAK,GAAG,IAAZ;;AAEA/C,IAAAA,eAAe,CAAC,IAAD,EAAO2C,gBAAP,CAAf;;AAEA,SAAKK,qBAAL,GAA6B,UAAUC,QAAV,EAAoB;AAC/C,UAAIC,OAAO,GAAGH,KAAK,CAACI,WAAN,CAAkBC,GAAlB,CAAsBH,QAAtB,CAAd;;AAEA,aAAOC,OAAO,IAAIrB,mBAAmB,CAACqB,OAAD,CAArC;AACD,KAJD;;AAMA,SAAKG,yBAAL,GAAiC,UAAUC,CAAV,EAAa;AAC5C,UAAI,CAAC7B,oBAAoB,CAAC6B,CAAD,CAAzB,EAA8B;AAC5B;AACD;;AAEDP,MAAAA,KAAK,CAACQ,kBAAN,GAA2B,EAA3B;AACD,KAND;;AAQA,SAAKC,eAAL,GAAuB,UAAUP,QAAV,EAAoB;AACzC;AACA;AACA,UAAIQ,KAAK,CAACC,OAAN,CAAcX,KAAK,CAACQ,kBAApB,CAAJ,EAA6C;AAC3CR,QAAAA,KAAK,CAACQ,kBAAN,CAAyBI,OAAzB,CAAiCV,QAAjC;AACD;AACF,KAND;;AAQA,SAAKW,kBAAL,GAA0B,UAAUN,CAAV,EAAa;AACrC,UAAI,CAAC7B,oBAAoB,CAAC6B,CAAD,CAAzB,EAA8B;AAC5B;AACD,OAHoC,CAGnC;AACF;AACA;AACA;;;AAGA,UAAIO,YAAY,GAAGjC,oBAAoB,CAAC0B,CAAD,CAAvC;;AAEA,UAAIO,YAAJ,EAAkB;AAChB,YAAIlC,YAAY,CAAC2B,CAAD,CAAhB,EAAqB;AACnBP,UAAAA,KAAK,CAACe,uBAAN,GAAgCR,CAAC,CAACS,aAAF,CAAgB,CAAhB,CAAhC;AACD;;AAEDhB,QAAAA,KAAK,CAACiB,kBAAN,GAA2BH,YAA3B;AACD;;AAEDd,MAAAA,KAAK,CAACkB,eAAN,GAAwB,KAAxB;AACD,KApBD;;AAsBA,SAAKC,uBAAL,GAA+B,UAAUZ,CAAV,EAAa;AAC1C,UAAI,CAAC7B,oBAAoB,CAAC6B,CAAD,CAAzB,EAA8B;AAC5B;AACD;;AAED,UAAIa,KAAK,GAAGb,CAAC,CAACc,IAAF,KAAWlC,UAAU,CAACM,KAAX,CAAiBJ,KAA5B,GAAoCW,KAAK,CAACD,OAAN,CAAcuB,eAAlD,GAAoEtB,KAAK,CAACD,OAAN,CAAcwB,eAA9F;AACAvB,MAAAA,KAAK,CAACwB,OAAN,GAAgBC,UAAU,CAACzB,KAAK,CAACa,kBAAN,CAAyBa,IAAzB,CAA8B1B,KAA9B,EAAqCO,CAArC,CAAD,EAA0Ca,KAA1C,CAA1B;AACApB,MAAAA,KAAK,CAACkB,eAAN,GAAwB,IAAxB;AACD,KARD;;AAUA,SAAKS,oBAAL,GAA4B,YAAY;AACtC3B,MAAAA,KAAK,CAAC4B,iBAAN,GAA0B,EAA1B;AACD,KAFD;;AAIA,SAAKC,UAAL,GAAkB,UAAUC,IAAV,EAAgBC,QAAhB,EAA0B;AAC1C,UAAI/B,KAAK,CAAC4B,iBAAV,EAA6B;AAC3B5B,QAAAA,KAAK,CAAC4B,iBAAN,CAAwBhB,OAAxB,CAAgCmB,QAAhC;AACD;AACF,KAJD;;AAMA,SAAKC,aAAL,GAAqB,UAAUzB,CAAV,EAAa;AAChC,UAAIP,KAAK,CAACwB,OAAV,EAAmB;AACjBS,QAAAA,YAAY,CAACjC,KAAK,CAACwB,OAAP,CAAZ;AACD;;AAED,UAAI,CAACxB,KAAK,CAACkC,QAAP,IAAmBlC,KAAK,CAACkB,eAA7B,EAA8C;AAC5C;AACD;;AAED,UAAIV,kBAAkB,GAAGR,KAAK,CAACQ,kBAA/B;AAAA,UACIoB,iBAAiB,GAAG5B,KAAK,CAAC4B,iBAD9B;AAEA,UAAIO,wBAAwB,GAAGnC,KAAK,CAACD,OAAN,CAAcoC,wBAA7C;AACA,UAAIrB,YAAY,GAAGjC,oBAAoB,CAAC0B,CAAD,EAAIP,KAAK,CAACe,uBAAV,CAAvC;;AAEA,UAAI,CAACD,YAAL,EAAmB;AACjB;AACD,OAhB+B,CAgB9B;;;AAGF,UAAId,KAAK,CAACoC,YAAN,IAAsB,CAACpC,KAAK,CAACqC,OAAN,CAAcC,UAAd,EAAD,IAA+BtD,aAAa,CAACgB,KAAK,CAACiB,kBAAN,CAAyBsB,CAAzB,IAA8B,CAA/B,EAAkCvC,KAAK,CAACiB,kBAAN,CAAyBuB,CAAzB,IAA8B,CAAhE,EAAmE1B,YAAY,CAACyB,CAAhF,EAAmFzB,YAAY,CAAC0B,CAAhG,EAAmGxC,KAAK,CAACD,OAAN,CAAc0C,iBAAjH,CAAtE,EAA2M;AACzMzC,QAAAA,KAAK,CAACoC,YAAN,GAAqB,IAArB;AACA;AACD,OAtB+B,CAsB9B;;;AAGF,UAAI,CAACpC,KAAK,CAACqC,OAAN,CAAcC,UAAd,EAAD,IAA+B;AACnCtC,MAAAA,KAAK,CAACiB,kBAAN,CAAyByB,cAAzB,CAAwC,GAAxC,CADI,IAC4ClC,kBAD5C,IACkEzB,QAAQ,CAACiB,KAAK,CAACiB,kBAAN,CAAyBsB,CAAzB,IAA8B,CAA/B,EAAkCvC,KAAK,CAACiB,kBAAN,CAAyBuB,CAAzB,IAA8B,CAAhE,EAAmE1B,YAAY,CAACyB,CAAhF,EAAmFzB,YAAY,CAAC0B,CAAhG,CAAR,IAA8GxC,KAAK,CAACD,OAAN,CAAc4C,SAAd,GAA0B3C,KAAK,CAACD,OAAN,CAAc4C,SAAxC,GAAoD,CAAlK,CADtE,EAC4O;AAC1O3C,QAAAA,KAAK,CAACQ,kBAAN,GAA2BoC,SAA3B;;AAEA5C,QAAAA,KAAK,CAAC6C,OAAN,CAAcC,SAAd,CAAwBtC,kBAAxB,EAA4C;AAC1CM,UAAAA,YAAY,EAAEd,KAAK,CAACiB,kBADsB;AAE1ChB,UAAAA,qBAAqB,EAAED,KAAK,CAACC,qBAFa;AAG1C8C,UAAAA,aAAa,EAAE;AAH2B,SAA5C;AAKD;;AAED,UAAI,CAAC/C,KAAK,CAACqC,OAAN,CAAcC,UAAd,EAAL,EAAiC;AAC/B;AACD;;AAED,UAAIU,UAAU,GAAGhD,KAAK,CAACI,WAAN,CAAkBC,GAAlB,CAAsBL,KAAK,CAACqC,OAAN,CAAcY,WAAd,EAAtB,CAAjB;;AAEAjD,MAAAA,KAAK,CAACkD,gCAAN,CAAuCF,UAAvC;;AAEAhD,MAAAA,KAAK,CAAC6C,OAAN,CAAcM,iBAAd;;AAEA,UAAI5C,CAAC,CAAC6C,UAAN,EAAkB7C,CAAC,CAAC8C,cAAF,GA9Cc,CA8CM;;AAEtC,UAAIC,mBAAmB,GAAG,CAAC1B,iBAAiB,IAAI,EAAtB,EAA0B2B,GAA1B,CAA8B,UAAUvF,GAAV,EAAe;AACrE,eAAOgC,KAAK,CAACwD,WAAN,CAAkBnD,GAAlB,CAAsBrC,GAAtB,CAAP;AACD,OAFyB,EAEvByF,MAFuB,CAEhB,UAAUlD,CAAV,EAAa;AACrB,eAAO,CAAC,CAACA,CAAT;AACD,OAJyB,CAA1B,CAhDgC,CAoD5B;;AAEJ,UAAImD,eAAe,GAAG1D,KAAK,CAACD,OAAN,CAAc4D,4BAAd,GAA6C3D,KAAK,CAACD,OAAN,CAAc4D,4BAAd,CAA2C7C,YAAY,CAACyB,CAAxD,EAA2DzB,YAAY,CAAC0B,CAAxE,EAA2Ec,mBAA3E,CAA7C,GAA+ItD,KAAK,CAACkC,QAAN,CAAe0B,iBAAf,CAAiC9C,YAAY,CAACyB,CAA9C,EAAiDzB,YAAY,CAAC0B,CAA9D,CAArK,CAtDgC,CAsDuM;;AAEvO,UAAIqB,uBAAuB,GAAG,EAA9B;;AAEA,WAAK,IAAIC,MAAT,IAAmBJ,eAAnB,EAAoC;AAClC;AACA,YAAI,CAACA,eAAe,CAAChB,cAAhB,CAA+BoB,MAA/B,CAAL,EAA6C;AAC3C;AACD;;AAED,YAAIC,WAAW,GAAGL,eAAe,CAACI,MAAD,CAAjC;AACAD,QAAAA,uBAAuB,CAACG,IAAxB,CAA6BD,WAA7B;;AAEA,eAAOA,WAAP,EAAoB;AAClBA,UAAAA,WAAW,GAAGA,WAAW,CAACE,aAA1B;;AAEA,cAAIF,WAAW,IAAIF,uBAAuB,CAACK,OAAxB,CAAgCH,WAAhC,MAAiD,CAAC,CAArE,EAAwE;AACtEF,YAAAA,uBAAuB,CAACG,IAAxB,CAA6BD,WAA7B;AACD;AACF;AACF;;AAED,UAAII,wBAAwB,GAAGN,uBAAuB,CAAC;AAAD,OACrDJ,MAD8B,CACvB,UAAUW,IAAV,EAAgB;AACtB,eAAOd,mBAAmB,CAACY,OAApB,CAA4BE,IAA5B,IAAoC,CAAC,CAA5C;AACD,OAH8B,EAG5B;AAH4B,OAI9Bb,GAJ8B,CAI1B,UAAUa,IAAV,EAAgB;AACnB,eAAOpE,KAAK,CAACqE,gBAAN,CAAuBD,IAAvB,CAAP;AACD,OAN8B,EAM5B;AAN4B,OAO9BX,MAP8B,CAOvB,UAAUW,IAAV,EAAgB;AACtB,eAAO,CAAC,CAACA,IAAT;AACD,OAT8B,EAS5BX,MAT4B,CASrB,UAAUa,EAAV,EAAcC,KAAd,EAAqBC,GAArB,EAA0B;AAClC,eAAOA,GAAG,CAACN,OAAJ,CAAYI,EAAZ,MAAoBC,KAA3B;AACD,OAX8B,CAA/B,CA5EgC,CAuF5B;;AAEJ,UAAIpC,wBAAJ,EAA8B;AAC5B,aAAK,IAAIJ,QAAT,IAAqB/B,KAAK,CAACwD,WAA3B,EAAwC;AACtC,cAAIiB,UAAU,GAAGzE,KAAK,CAACwD,WAAN,CAAkBnD,GAAlB,CAAsB0B,QAAtB,CAAjB;;AAEA,cAAIiB,UAAU,IAAIyB,UAAd,IAA4BA,UAAU,CAACC,QAAX,CAAoB1B,UAApB,CAA5B,IAA+DmB,wBAAwB,CAACD,OAAzB,CAAiCnC,QAAjC,MAA+C,CAAC,CAAnH,EAAsH;AACpHoC,YAAAA,wBAAwB,CAACvD,OAAzB,CAAiCmB,QAAjC;AACA;AACD;AACF;AACF,OAlG+B,CAkG9B;;;AAGFoC,MAAAA,wBAAwB,CAACQ,OAAzB;;AAEA3E,MAAAA,KAAK,CAAC6C,OAAN,CAAc+B,KAAd,CAAoBT,wBAApB,EAA8C;AAC5CrD,QAAAA,YAAY,EAAEA;AAD8B,OAA9C;AAGD,KA1GD;AA2GA;AACJ;AACA;AACA;;;AAGI,SAAKuD,gBAAL,GAAwB,UAAUD,IAAV,EAAgB;AACtC,UAAIS,IAAI,GAAG7E,KAAK,CAACwD,WAAN,CAAkBqB,IAAlB,EAAX;;AAEA,UAAIC,IAAI,GAAGD,IAAI,CAACC,IAAL,EAAX;;AAEA,aAAOA,IAAI,CAACC,IAAL,KAAc,KAArB,EAA4B;AAC1B,YAAIhD,QAAQ,GAAG+C,IAAI,CAACvG,KAApB;;AAEA,YAAI6F,IAAI,KAAKpE,KAAK,CAACwD,WAAN,CAAkBnD,GAAlB,CAAsB0B,QAAtB,CAAb,EAA8C;AAC5C,iBAAOA,QAAP;AACD,SAFD,MAEO;AACL+C,UAAAA,IAAI,GAAGD,IAAI,CAACC,IAAL,EAAP;AACD;AACF;;AAED,aAAOlC,SAAP;AACD,KAhBD;;AAkBA,SAAKoC,uBAAL,GAA+B,UAAUzE,CAAV,EAAa;AAC1CP,MAAAA,KAAK,CAACoC,YAAN,GAAqB,KAArB;AACApC,MAAAA,KAAK,CAACe,uBAAN,GAAgC6B,SAAhC;;AAEA,UAAI,CAACjE,kBAAkB,CAAC4B,CAAD,CAAvB,EAA4B;AAC1B;AACD;;AAED,UAAI,CAACP,KAAK,CAACqC,OAAN,CAAcC,UAAd,EAAD,IAA+BtC,KAAK,CAACqC,OAAN,CAAc4C,OAAd,EAAnC,EAA4D;AAC1DjF,QAAAA,KAAK,CAACQ,kBAAN,GAA2BoC,SAA3B;AACA;AACD;;AAED,UAAIrC,CAAC,CAAC6C,UAAN,EAAkB7C,CAAC,CAAC8C,cAAF;AAClBrD,MAAAA,KAAK,CAACiB,kBAAN,GAA2B,EAA3B;;AAEAjB,MAAAA,KAAK,CAACkF,kCAAN;;AAEAlF,MAAAA,KAAK,CAAC6C,OAAN,CAAcsC,IAAd;;AAEAnF,MAAAA,KAAK,CAAC6C,OAAN,CAAcuC,OAAd;AACD,KArBD;;AAuBA,SAAKC,oBAAL,GAA4B,UAAU9E,CAAV,EAAa;AACvC,UAAIA,CAAC,CAACvC,GAAF,KAAU,QAAV,IAAsBgC,KAAK,CAACqC,OAAN,CAAcC,UAAd,EAA1B,EAAsD;AACpDtC,QAAAA,KAAK,CAACiB,kBAAN,GAA2B,EAA3B;;AAEAjB,QAAAA,KAAK,CAACkF,kCAAN;;AAEAlF,QAAAA,KAAK,CAAC6C,OAAN,CAAcuC,OAAd;AACD;AACF,KARD;;AAUA,SAAKrF,OAAL,GAAe,IAAIb,aAAJ,CAAkBa,OAAlB,EAA2BD,OAA3B,CAAf;AACA,SAAK+C,OAAL,GAAehD,OAAO,CAACyF,UAAR,EAAf;AACA,SAAKjD,OAAL,GAAexC,OAAO,CAAC0F,UAAR,EAAf;AACA,SAAKnF,WAAL,GAAmB,IAAIoF,GAAJ,EAAnB;AACA,SAAKC,kBAAL,GAA0B,IAAID,GAAJ,EAA1B;AACA,SAAKE,wBAAL,GAAgC,IAAIF,GAAJ,EAAhC;AACA,SAAKhC,WAAL,GAAmB,IAAIgC,GAAJ,EAAnB;AACA,SAAKG,aAAL,GAAqB,EAArB;AACA,SAAK1E,kBAAL,GAA0B,EAA1B;AACA,SAAKmB,YAAL,GAAoB,KAApB;;AAEA,QAAI,KAAKrC,OAAL,CAAa6F,iBAAjB,EAAoC;AAClC,WAAKD,aAAL,CAAmB3B,IAAnB,CAAwBvF,YAAY,CAACW,KAArC;AACD;;AAED,QAAI,KAAKW,OAAL,CAAa8F,iBAAjB,EAAoC;AAClC,WAAKF,aAAL,CAAmB3B,IAAnB,CAAwBvF,YAAY,CAACgB,KAArC;AACD;;AAED,QAAI,KAAKM,OAAL,CAAa+F,oBAAjB,EAAuC;AACrC,WAAKH,aAAL,CAAmB3B,IAAnB,CAAwBvF,YAAY,CAACiB,QAArC;AACD;AACF;AACD;AACF;AACA;;;AAGEzB,EAAAA,YAAY,CAAC2B,gBAAD,EAAmB,CAAC;AAC9B5B,IAAAA,GAAG,EAAE,SADyB;AAE9BO,IAAAA,KAAK,EAAE,SAASwH,OAAT,GAAmB;AACxB,UAAIC,qBAAJ;;AAEA,aAAO;AACL5F,QAAAA,WAAW,EAAE,KAAKA,WAAL,CAAiB6F,IADzB;AAELR,QAAAA,kBAAkB,EAAE,KAAKA,kBAAL,CAAwBQ,IAFvC;AAGLP,QAAAA,wBAAwB,EAAE,KAAKA,wBAAL,CAA8BO,IAHnD;AAILzC,QAAAA,WAAW,EAAE,KAAKA,WAAL,CAAiByC,IAJzB;AAKLrE,QAAAA,iBAAiB,EAAE,CAAC,CAACoE,qBAAqB,GAAG,KAAKpE,iBAA9B,MAAqD,IAArD,IAA6DoE,qBAAqB,KAAK,KAAK,CAA5F,GAAgG,KAAK,CAArG,GAAyGA,qBAAqB,CAACvI,MAAhI,KAA2I;AALzJ,OAAP;AAOD,KAZ6B,CAY5B;;AAZ4B,GAAD,EAc5B;AACDO,IAAAA,GAAG,EAAE,OADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS2H,KAAT,GAAiB;AACtB,UAAI,CAAC,KAAKC,MAAV,EAAkB;AAChB;AACD;;AAED3H,MAAAA,SAAS,CAAC,CAACoB,gBAAgB,CAACwG,OAAnB,EAA4B,kDAA5B,CAAT;AACAxG,MAAAA,gBAAgB,CAACwG,OAAjB,GAA2B,IAA3B;AACA,WAAKC,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,OAAnC,EAA4C,KAAKG,sBAAL,EAA5C;AACA,WAAKD,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,OAAnC,EAA4C,KAAK7F,yBAAjD,EAA4E,IAA5E;AACA,WAAK+F,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,MAAnC,EAA2C,KAAKnE,aAAhD;AACA,WAAKqE,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,MAAnC,EAA2C,KAAKxE,oBAAhD,EAAsE,IAAtE;AACA,WAAK0E,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,KAAnC,EAA0C,KAAKnB,uBAA/C,EAAwE,IAAxE;;AAEA,UAAI,KAAKjF,OAAL,CAAa6F,iBAAb,IAAkC,CAAC,KAAK7F,OAAL,CAAawG,iBAApD,EAAuE;AACrE,aAAKF,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,aAAnC,EAAkD,KAAKnB,uBAAvD;AACD;;AAED,UAAI,KAAKjF,OAAL,CAAa+F,oBAAjB,EAAuC;AACrC,aAAKO,gBAAL,CAAsB,KAAKF,MAA3B,EAAmC,SAAnC,EAA8C,KAAKd,oBAAnD,EAAyE,IAAzE;AACD;AACF;AAtBA,GAd4B,EAqC5B;AACDrH,IAAAA,GAAG,EAAE,UADJ;AAEDO,IAAAA,KAAK,EAAE,SAASiI,QAAT,GAAoB;AACzB,UAAI,CAAC,KAAKL,MAAV,EAAkB;AAChB;AACD;;AAEDvG,MAAAA,gBAAgB,CAACwG,OAAjB,GAA2B,KAA3B;AACA,WAAKnF,kBAAL,GAA0B,EAA1B;AACA,WAAKwF,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,OAAtC,EAA+C,KAAK7F,yBAApD,EAA+E,IAA/E;AACA,WAAKmG,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,OAAtC,EAA+C,KAAKtF,kBAApD;AACA,WAAK4F,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,MAAtC,EAA8C,KAAKxE,oBAAnD,EAAyE,IAAzE;AACA,WAAK8E,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,MAAtC,EAA8C,KAAKnE,aAAnD;AACA,WAAKyE,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,KAAtC,EAA6C,KAAKnB,uBAAlD,EAA2E,IAA3E;;AAEA,UAAI,KAAKjF,OAAL,CAAa6F,iBAAb,IAAkC,CAAC,KAAK7F,OAAL,CAAawG,iBAApD,EAAuE;AACrE,aAAKE,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,aAAtC,EAAqD,KAAKnB,uBAA1D;AACD;;AAED,UAAI,KAAKjF,OAAL,CAAa+F,oBAAjB,EAAuC;AACrC,aAAKW,mBAAL,CAAyB,KAAKN,MAA9B,EAAsC,SAAtC,EAAiD,KAAKd,oBAAtD,EAA4E,IAA5E;AACD;;AAED,WAAKH,kCAAL;AACD;AAxBA,GArC4B,EA8D5B;AACDlH,IAAAA,GAAG,EAAE,kBADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS8H,gBAAT,CAA0BK,OAA1B,EAAmCC,KAAnC,EAA0CC,OAA1C,EAAmDC,OAAnD,EAA4D;AACjE,UAAI9G,OAAO,GAAGd,eAAe,GAAG;AAC9B4H,QAAAA,OAAO,EAAEA,OADqB;AAE9BC,QAAAA,OAAO,EAAE;AAFqB,OAAH,GAGzBD,OAHJ;AAIA,WAAKlB,aAAL,CAAmBoB,OAAnB,CAA2B,UAAUC,YAAV,EAAwB;AACjD,YAAIC,GAAG,GAAG9H,UAAU,CAAC6H,YAAD,CAAV,CAAyBL,KAAzB,CAAV;;AAEA,YAAIM,GAAJ,EAAS;AACPP,UAAAA,OAAO,CAACL,gBAAR,CAAyBY,GAAzB,EAA8BL,OAA9B,EAAuC7G,OAAvC;AACD;AACF,OAND;AAOD;AAdA,GA9D4B,EA6E5B;AACD/B,IAAAA,GAAG,EAAE,qBADJ;AAEDO,IAAAA,KAAK,EAAE,SAASkI,mBAAT,CAA6BC,OAA7B,EAAsCC,KAAtC,EAA6CC,OAA7C,EAAsDC,OAAtD,EAA+D;AACpE,UAAI9G,OAAO,GAAGd,eAAe,GAAG;AAC9B4H,QAAAA,OAAO,EAAEA,OADqB;AAE9BC,QAAAA,OAAO,EAAE;AAFqB,OAAH,GAGzBD,OAHJ;AAIA,WAAKlB,aAAL,CAAmBoB,OAAnB,CAA2B,UAAUC,YAAV,EAAwB;AACjD,YAAIC,GAAG,GAAG9H,UAAU,CAAC6H,YAAD,CAAV,CAAyBL,KAAzB,CAAV;;AAEA,YAAIM,GAAJ,EAAS;AACPP,UAAAA,OAAO,CAACD,mBAAR,CAA4BQ,GAA5B,EAAiCL,OAAjC,EAA0C7G,OAA1C;AACD;AACF,OAND;AAOD;AAdA,GA7E4B,EA4F5B;AACD/B,IAAAA,GAAG,EAAE,mBADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS2I,iBAAT,CAA2BhH,QAA3B,EAAqCkE,IAArC,EAA2C;AAChD,UAAI+C,MAAM,GAAG,IAAb;;AAEA,UAAI1G,eAAe,GAAG,KAAKA,eAAL,CAAqBiB,IAArB,CAA0B,IAA1B,EAAgCxB,QAAhC,CAAtB;AACA,WAAKE,WAAL,CAAiBgH,GAAjB,CAAqBlH,QAArB,EAA+BkE,IAA/B;AACA,WAAKiC,gBAAL,CAAsBjC,IAAtB,EAA4B,OAA5B,EAAqC3D,eAArC;AACA,aAAO,YAAY;AACjB0G,QAAAA,MAAM,CAAC/G,WAAP,CAAmBiH,MAAnB,CAA0BnH,QAA1B;;AAEAiH,QAAAA,MAAM,CAACV,mBAAP,CAA2BrC,IAA3B,EAAiC,OAAjC,EAA0C3D,eAA1C;AACD,OAJD;AAKD;AAbA,GA5F4B,EA0G5B;AACDzC,IAAAA,GAAG,EAAE,oBADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS+I,kBAAT,CAA4BpH,QAA5B,EAAsCkE,IAAtC,EAA4CrE,OAA5C,EAAqD;AAC1D,UAAIwH,MAAM,GAAG,IAAb;;AAEA,WAAK7B,wBAAL,CAA8B0B,GAA9B,CAAkClH,QAAlC,EAA4CH,OAA5C;AACA,WAAK0F,kBAAL,CAAwB2B,GAAxB,CAA4BlH,QAA5B,EAAsCkE,IAAtC;AACA,aAAO,YAAY;AACjBmD,QAAAA,MAAM,CAAC9B,kBAAP,CAA0B4B,MAA1B,CAAiCnH,QAAjC;;AAEAqH,QAAAA,MAAM,CAAC7B,wBAAP,CAAgC2B,MAAhC,CAAuCnH,QAAvC;AACD,OAJD;AAKD;AAZA,GA1G4B,EAuH5B;AACDlC,IAAAA,GAAG,EAAE,mBADJ;AAEDO,IAAAA,KAAK,EAAE,SAASiJ,iBAAT,CAA2BzF,QAA3B,EAAqCqC,IAArC,EAA2C;AAChD,UAAIqD,MAAM,GAAG,IAAb;;AAEA,UAAI,CAAC,KAAKvF,QAAV,EAAoB;AAClB,eAAO,YAAY;AACjB;AACD,SAFD;AAGD;;AAED,UAAIL,UAAU,GAAG,SAASA,UAAT,CAAoBtB,CAApB,EAAuB;AACtC,YAAI,CAACkH,MAAM,CAACvF,QAAR,IAAoB,CAACuF,MAAM,CAACpF,OAAP,CAAeC,UAAf,EAAzB,EAAsD;AACpD;AACD;;AAED,YAAIoF,MAAJ;AACA;AACR;AACA;;AAEQ,gBAAQnH,CAAC,CAACc,IAAV;AACE,eAAKlC,UAAU,CAACC,KAAX,CAAiBE,IAAtB;AACEoI,YAAAA,MAAM,GAAG;AACPnF,cAAAA,CAAC,EAAEhC,CAAC,CAACoH,OADE;AAEPnF,cAAAA,CAAC,EAAEjC,CAAC,CAACqH;AAFE,aAAT;AAIA;;AAEF,eAAKzI,UAAU,CAACM,KAAX,CAAiBH,IAAtB;AACEoI,YAAAA,MAAM,GAAG;AACPnF,cAAAA,CAAC,EAAEhC,CAAC,CAACsH,OAAF,CAAU,CAAV,EAAaF,OADT;AAEPnF,cAAAA,CAAC,EAAEjC,CAAC,CAACsH,OAAF,CAAU,CAAV,EAAaD;AAFT,aAAT;AAIA;AAbJ;AAeA;AACR;AACA;AACA;;;AAGQ,YAAIE,SAAS,GAAGJ,MAAM,IAAI,IAAV,GAAiBD,MAAM,CAACvF,QAAP,CAAgB6F,gBAAhB,CAAiCL,MAAM,CAACnF,CAAxC,EAA2CmF,MAAM,CAAClF,CAAlD,CAAjB,GAAwEI,SAAxF;AACA,YAAIoF,UAAU,GAAGF,SAAS,IAAI1D,IAAI,CAACM,QAAL,CAAcoD,SAAd,CAA9B;;AAEA,YAAIA,SAAS,KAAK1D,IAAd,IAAsB4D,UAA1B,EAAsC;AACpC,iBAAOP,MAAM,CAAC5F,UAAP,CAAkBtB,CAAlB,EAAqBwB,QAArB,CAAP;AACD;AACF,OArCD;AAsCA;AACN;AACA;;;AAGM,WAAKsE,gBAAL,CAAsB,KAAKnE,QAAL,CAAc+F,IAApC,EAA0C,MAA1C,EAAkDpG,UAAlD;AACA,WAAK2B,WAAL,CAAiB4D,GAAjB,CAAqBrF,QAArB,EAA+BqC,IAA/B;AACA,aAAO,YAAY;AACjB,YAAIqD,MAAM,CAACvF,QAAX,EAAqB;AACnBuF,UAAAA,MAAM,CAACjE,WAAP,CAAmB6D,MAAnB,CAA0BtF,QAA1B;;AAEA0F,UAAAA,MAAM,CAAChB,mBAAP,CAA2BgB,MAAM,CAACvF,QAAP,CAAgB+F,IAA3C,EAAiD,MAAjD,EAAyDpG,UAAzD;AACD;AACF,OAND;AAOD;AA/DA,GAvH4B,EAuL5B;AACD7D,IAAAA,GAAG,EAAE,wBADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS+H,sBAAT,GAAkC;AACvC,UAAI,CAAC,KAAKvG,OAAL,CAAauB,eAAd,IAAiC,CAAC,KAAKvB,OAAL,CAAawB,eAAnD,EAAoE;AAClE,eAAO,KAAKV,kBAAZ;AACD;;AAED,aAAO,KAAKM,uBAAZ;AACD;AARA,GAvL4B,EAgM5B;AACDnD,IAAAA,GAAG,EAAE,kCADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS2E,gCAAT,CAA0CkB,IAA1C,EAAgD;AACrD,UAAI8D,MAAM,GAAG,IAAb;;AAEA,WAAKhD,kCAAL;AACA,WAAKiD,iBAAL,GAAyB/D,IAAzB;AACA,WAAKgE,gCAAL,GAAwC,IAAIC,gBAAJ,CAAqB,YAAY;AACvE,YAAIjE,IAAI,IAAI,CAACA,IAAI,CAACH,aAAlB,EAAiC;AAC/BiE,UAAAA,MAAM,CAACI,mBAAP;;AAEAJ,UAAAA,MAAM,CAAChD,kCAAP;AACD;AACF,OANuC,CAAxC;;AAQA,UAAI,CAACd,IAAD,IAAS,CAACA,IAAI,CAACH,aAAnB,EAAkC;AAChC;AACD;;AAED,WAAKmE,gCAAL,CAAsCG,OAAtC,CAA8CnE,IAAI,CAACH,aAAnD,EAAkE;AAChEuE,QAAAA,SAAS,EAAE;AADqD,OAAlE;AAGD;AAtBA,GAhM4B,EAuN5B;AACDxK,IAAAA,GAAG,EAAE,qBADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS+J,mBAAT,GAA+B;AACpC,UAAI,KAAKpG,QAAL,IAAiB,KAAKiG,iBAA1B,EAA6C;AAC3C,aAAKA,iBAAL,CAAuBM,KAAvB,CAA6BC,OAA7B,GAAuC,MAAvC;AACA,aAAKP,iBAAL,CAAuBQ,eAAvB,CAAuC,cAAvC;AACA,aAAKzG,QAAL,CAAc+F,IAAd,CAAmBW,WAAnB,CAA+B,KAAKT,iBAApC;AACD;AACF;AARA,GAvN4B,EAgO5B;AACDnK,IAAAA,GAAG,EAAE,oCADJ;AAEDO,IAAAA,KAAK,EAAE,SAAS2G,kCAAT,GAA8C;AACnD,UAAI,KAAKkD,gCAAT,EAA2C;AACzC,aAAKA,gCAAL,CAAsCS,UAAtC;AACD;;AAED,WAAKT,gCAAL,GAAwCxF,SAAxC;AACA,WAAKuF,iBAAL,GAAyBvF,SAAzB;AACD;AATA,GAhO4B,EA0O5B;AACD5E,IAAAA,GAAG,EAAE,QADJ;AAEDqC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKN,OAAL,CAAaoG,MAApB;AACD,KAJA,CAIC;;AAJD,GA1O4B,EAgP5B;AACDnI,IAAAA,GAAG,EAAE,UADJ;AAEDqC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,UAAI,KAAK8F,MAAT,EAAiB;AACf,eAAO,KAAKA,MAAL,CAAYjE,QAAnB;AACD;;AAED,aAAOU,SAAP;AACD;AARA,GAhP4B,CAAnB,CAAZ;;AA2PA,SAAOhD,gBAAP;AACD,CAlgB0C,EAApC","sourcesContent":["var _eventNames;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces';\nimport { eventShouldStartDrag, eventShouldEndDrag, isTouchEvent } from './utils/predicates';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets';\nimport { distance, inAngleRanges } from './utils/math';\nimport { supportsPassive } from './utils/supportsPassive';\nimport { OptionsReader } from './OptionsReader';\nvar eventNames = (_eventNames = {}, _defineProperty(_eventNames, ListenerType.mouse, {\n  start: 'mousedown',\n  move: 'mousemove',\n  end: 'mouseup',\n  contextmenu: 'contextmenu'\n}), _defineProperty(_eventNames, ListenerType.touch, {\n  start: 'touchstart',\n  move: 'touchmove',\n  end: 'touchend'\n}), _defineProperty(_eventNames, ListenerType.keyboard, {\n  keydown: 'keydown'\n}), _eventNames);\nexport var TouchBackendImpl = /*#__PURE__*/function () {\n  function TouchBackendImpl(manager, context, options) {\n    var _this = this;\n\n    _classCallCheck(this, TouchBackendImpl);\n\n    this.getSourceClientOffset = function (sourceId) {\n      var element = _this.sourceNodes.get(sourceId);\n\n      return element && getNodeClientOffset(element);\n    };\n\n    this.handleTopMoveStartCapture = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      _this.moveStartSourceIds = [];\n    };\n\n    this.handleMoveStart = function (sourceId) {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(_this.moveStartSourceIds)) {\n        _this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n\n    this.handleTopMoveStart = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      } // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\n      var clientOffset = getEventClientOffset(e);\n\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          _this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n\n        _this._mouseClientOffset = clientOffset;\n      }\n\n      _this.waitingForDelay = false;\n    };\n\n    this.handleTopMoveStartDelay = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n\n      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;\n      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n      _this.waitingForDelay = true;\n    };\n\n    this.handleTopMoveCapture = function () {\n      _this.dragOverTargetIds = [];\n    };\n\n    this.handleMove = function (_evt, targetId) {\n      if (_this.dragOverTargetIds) {\n        _this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n\n    this.handleTopMove = function (e) {\n      if (_this.timeout) {\n        clearTimeout(_this.timeout);\n      }\n\n      if (!_this.document || _this.waitingForDelay) {\n        return;\n      }\n\n      var moveStartSourceIds = _this.moveStartSourceIds,\n          dragOverTargetIds = _this.dragOverTargetIds;\n      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n      var clientOffset = getEventClientOffset(e, _this.lastTargetTouchFallback);\n\n      if (!clientOffset) {\n        return;\n      } // If the touch move started as a scroll, or is is between the scroll angles\n\n\n      if (_this._isScrolling || !_this.monitor.isDragging() && inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {\n        _this._isScrolling = true;\n        return;\n      } // If we're not dragging and we've moved a little, that counts as a drag start\n\n\n      if (!_this.monitor.isDragging() && // eslint-disable-next-line no-prototype-builtins\n      _this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n        _this.moveStartSourceIds = undefined;\n\n        _this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: _this._mouseClientOffset,\n          getSourceClientOffset: _this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n\n      if (!_this.monitor.isDragging()) {\n        return;\n      }\n\n      var sourceNode = _this.sourceNodes.get(_this.monitor.getSourceId());\n\n      _this.installSourceNodeRemovalObserver(sourceNode);\n\n      _this.actions.publishDragSource();\n\n      if (e.cancelable) e.preventDefault(); // Get the node elements of the hovered DropTargets\n\n      var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) {\n        return _this.targetNodes.get(key);\n      }).filter(function (e) {\n        return !!e;\n      }); // Get the a ordered list of nodes that are touched by\n\n      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y); // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\n      var elementsAtPointExtended = [];\n\n      for (var nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n\n        var currentNode = elementsAtPoint[nodeId];\n        elementsAtPointExtended.push(currentNode);\n\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n\n      var orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(function (node) {\n        return dragOverTargetNodes.indexOf(node) > -1;\n      }) // Map back the nodes elements to targetIds\n      .map(function (node) {\n        return _this._getDropTargetId(node);\n      }) // Filter off possible null rows\n      .filter(function (node) {\n        return !!node;\n      }).filter(function (id, index, ids) {\n        return ids.indexOf(id) === index;\n      }); // Invoke hover for drop targets when source node is still over and pointer is outside\n\n      if (enableHoverOutsideTarget) {\n        for (var targetId in _this.targetNodes) {\n          var targetNode = _this.targetNodes.get(targetId);\n\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      } // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\n\n      orderedDragOverTargetIds.reverse();\n\n      _this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n     *\n     * visible for testing\n     */\n\n\n    this._getDropTargetId = function (node) {\n      var keys = _this.targetNodes.keys();\n\n      var next = keys.next();\n\n      while (next.done === false) {\n        var targetId = next.value;\n\n        if (node === _this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n\n      return undefined;\n    };\n\n    this.handleTopMoveEndCapture = function (e) {\n      _this._isScrolling = false;\n      _this.lastTargetTouchFallback = undefined;\n\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n\n      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n        _this.moveStartSourceIds = undefined;\n        return;\n      }\n\n      if (e.cancelable) e.preventDefault();\n      _this._mouseClientOffset = {};\n\n      _this.uninstallSourceNodeRemovalObserver();\n\n      _this.actions.drop();\n\n      _this.actions.endDrag();\n    };\n\n    this.handleCancelOnEscape = function (e) {\n      if (e.key === 'Escape' && _this.monitor.isDragging()) {\n        _this._mouseClientOffset = {};\n\n        _this.uninstallSourceNodeRemovalObserver();\n\n        _this.actions.endDrag();\n      }\n    };\n\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n  /**\n   * Generate profiling statistics for the HTML5Backend.\n   */\n\n\n  _createClass(TouchBackendImpl, [{\n    key: \"profile\",\n    value: function profile() {\n      var _this$dragOverTargetI;\n\n      return {\n        sourceNodes: this.sourceNodes.size,\n        sourcePreviewNodes: this.sourcePreviewNodes.size,\n        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n        targetNodes: this.targetNodes.size,\n        dragOverTargetIds: ((_this$dragOverTargetI = this.dragOverTargetIds) === null || _this$dragOverTargetI === void 0 ? void 0 : _this$dragOverTargetI.length) || 0\n      };\n    } // public for test\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      if (!this.window) {\n        return;\n      }\n\n      invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n      TouchBackendImpl.isSetUp = true;\n      this.addEventListener(this.window, 'start', this.getTopMoveStartHandler());\n      this.addEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.addEventListener(this.window, 'move', this.handleTopMove);\n      this.addEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.addEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.addEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.addEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (!this.window) {\n        return;\n      }\n\n      TouchBackendImpl.isSetUp = false;\n      this._mouseClientOffset = {};\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStartCapture, true);\n      this.removeEventListener(this.window, 'start', this.handleTopMoveStart);\n      this.removeEventListener(this.window, 'move', this.handleTopMoveCapture, true);\n      this.removeEventListener(this.window, 'move', this.handleTopMove);\n      this.removeEventListener(this.window, 'end', this.handleTopMoveEndCapture, true);\n\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.removeEventListener(this.window, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n\n      if (this.options.enableKeyboardEvents) {\n        this.removeEventListener(this.window, 'keydown', this.handleCancelOnEscape, true);\n      }\n\n      this.uninstallSourceNodeRemovalObserver();\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.addEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(subject, event, handler, capture) {\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n\n        if (evt) {\n          subject.removeEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"connectDragSource\",\n    value: function connectDragSource(sourceId, node) {\n      var _this2 = this;\n\n      var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n      this.sourceNodes.set(sourceId, node);\n      this.addEventListener(node, 'start', handleMoveStart);\n      return function () {\n        _this2.sourceNodes.delete(sourceId);\n\n        _this2.removeEventListener(node, 'start', handleMoveStart);\n      };\n    }\n  }, {\n    key: \"connectDragPreview\",\n    value: function connectDragPreview(sourceId, node, options) {\n      var _this3 = this;\n\n      this.sourcePreviewNodeOptions.set(sourceId, options);\n      this.sourcePreviewNodes.set(sourceId, node);\n      return function () {\n        _this3.sourcePreviewNodes.delete(sourceId);\n\n        _this3.sourcePreviewNodeOptions.delete(sourceId);\n      };\n    }\n  }, {\n    key: \"connectDropTarget\",\n    value: function connectDropTarget(targetId, node) {\n      var _this4 = this;\n\n      if (!this.document) {\n        return function () {\n          /* noop */\n        };\n      }\n\n      var handleMove = function handleMove(e) {\n        if (!_this4.document || !_this4.monitor.isDragging()) {\n          return;\n        }\n\n        var coords;\n        /**\n         * Grab the coordinates for the current mouse/touch position\n         */\n\n        switch (e.type) {\n          case eventNames.mouse.move:\n            coords = {\n              x: e.clientX,\n              y: e.clientY\n            };\n            break;\n\n          case eventNames.touch.move:\n            coords = {\n              x: e.touches[0].clientX,\n              y: e.touches[0].clientY\n            };\n            break;\n        }\n        /**\n         * Use the coordinates to grab the element the drag ended on.\n         * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n         */\n\n\n        var droppedOn = coords != null ? _this4.document.elementFromPoint(coords.x, coords.y) : undefined;\n        var childMatch = droppedOn && node.contains(droppedOn);\n\n        if (droppedOn === node || childMatch) {\n          return _this4.handleMove(e, targetId);\n        }\n      };\n      /**\n       * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n       */\n\n\n      this.addEventListener(this.document.body, 'move', handleMove);\n      this.targetNodes.set(targetId, node);\n      return function () {\n        if (_this4.document) {\n          _this4.targetNodes.delete(targetId);\n\n          _this4.removeEventListener(_this4.document.body, 'move', handleMove);\n        }\n      };\n    }\n  }, {\n    key: \"getTopMoveStartHandler\",\n    value: function getTopMoveStartHandler() {\n      if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n        return this.handleTopMoveStart;\n      }\n\n      return this.handleTopMoveStartDelay;\n    }\n  }, {\n    key: \"installSourceNodeRemovalObserver\",\n    value: function installSourceNodeRemovalObserver(node) {\n      var _this5 = this;\n\n      this.uninstallSourceNodeRemovalObserver();\n      this.draggedSourceNode = node;\n      this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n        if (node && !node.parentElement) {\n          _this5.resurrectSourceNode();\n\n          _this5.uninstallSourceNodeRemovalObserver();\n        }\n      });\n\n      if (!node || !node.parentElement) {\n        return;\n      }\n\n      this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n        childList: true\n      });\n    }\n  }, {\n    key: \"resurrectSourceNode\",\n    value: function resurrectSourceNode() {\n      if (this.document && this.draggedSourceNode) {\n        this.draggedSourceNode.style.display = 'none';\n        this.draggedSourceNode.removeAttribute('data-reactid');\n        this.document.body.appendChild(this.draggedSourceNode);\n      }\n    }\n  }, {\n    key: \"uninstallSourceNodeRemovalObserver\",\n    value: function uninstallSourceNodeRemovalObserver() {\n      if (this.draggedSourceNodeRemovalObserver) {\n        this.draggedSourceNodeRemovalObserver.disconnect();\n      }\n\n      this.draggedSourceNodeRemovalObserver = undefined;\n      this.draggedSourceNode = undefined;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.options.window;\n    } // public for test\n\n  }, {\n    key: \"document\",\n    get: function get() {\n      if (this.window) {\n        return this.window.document;\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return TouchBackendImpl;\n}();"]},"metadata":{},"sourceType":"module"}